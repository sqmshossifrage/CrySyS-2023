I first searched online for key words such as "adaptor signature", "atomic swap", "MuSig protocol", and figured out that these concepts were built on top of each other. To solve this challenge, we need to learn the following components step by step:
1. [Schnorr signature](https://en.wikipedia.org/wiki/Schnorr_signature)
2. [Schnorr multi-signature (`MuSig` protocol)](https://eprint.iacr.org/2018/068.pdf)
3. [Adaptor signature and atomic swap](https://www.youtube.com/watch?v=ovCBT1gyk9c)


Let's fix some notations first. Given $\mathbb G$ a cyclic group of prime order $p$ generated by $G\in \mathbb G$. We adopt the additive notation on our group, that is, $P+Q$ instead of $P\cdot Q$, because we are secretly thinking about the [group structure on elliptive curve over finite field](https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law). We further denote $G + G$ as $2G$, and so on ([abelian groups](https://ncatlab.org/nlab/show/Ab) are $\mathbb{Z}$-modules). In particular, $pG = O$ where $O \in \mathbb G$ is the additive identity. We assume finding discrete logarithm in the group is hard, i.e. if we randomly choose an element $kG \in_R \mathbb G$, it's hard to find $k$. Denote $H: \lbrace 0,1\rbrace^* \to \mathbb{Z}_p$ a chosen hash function. We assume $(\mathbb G, G, p, H)$ are all known to the public. In general, lower case letters are elements of $\mathbb{Z}_p$, and upper case letters are elements of $\mathbb G$. 

## Schnorr Signature
Suppose Alice wants to sign a message $m$. She first randomly draws her secret key $x \in_R \mathbb {Z}_p$ and computes her public key $X = xG$. Then Alice randomly draws a secret nonce $r \in_R \mathbb {Z}_p$ and computes the public nonce $R = rG$, and challenge $c = H(X, R, m)$. Then she computes $s = r + cx$. In the end, $(m, X, R, c, s)$ are known to the public, and $(x, r)$ are kept as secret by Alice. 

Suppose Bob wants to verify Alice's signature, he just checks the following equality $$sG = R + cX$$

## Schnorr Multi-Signature
The Schnorr multi-signature, or `MuSig` protocol, is described in the paper [Simple Schnorr Multi-Signatures
with Applications to Bitcoin](https://eprint.iacr.org/2018/068.pdf). 


Multi-signature allows many parties to sign the same message and produce only one common signature. Recall that if $n$ parties sign a single message in a traditional way, they will produce $n$ signatures separately. With multi-signature, they only need to produce $1$ signature altogether.  

For the sake of simplicity, in our example there are only two parties $n=2$, Alice and Bob. We assume all hash functions used are the same. Now suppose both Alice and Bob want to sign a message $m$. 

They need to undergo the following steps:
1. They first draw their secret keys $x_A, x_B \in_R \mathbb {Z}_p$ and keep them secret. They then compute their public keys $X_A = x_AG$ and $X_B = x_BG$ and share the public keys with each other.
2. Both parties have obtained a multiset $L = \{X_A, X_B\}$ of public keys. They compute a unique encoding $\langle L\rangle$ of $L$. 
3. Then compute the following parameters: $$a_A = H(\langle L\rangle, X_A), \quad a_B = H(\langle L\rangle, X_B)$$
and obtain an aggregated public key $X = a_AX_A + a_BX_B$. 
4. They draw their secret nonces $r_A, r_B \in_R \mathbb {Z}_p$ and compute public nonces $R_A = r_AG$ and $R_B = r_BG$. They only share their public nonces. Both parties then compute an aggregated public nonce $R = R_A + R_B$. 
5. Now they are able to compute the challenges from public data $$c = H(X, R, m), \quad c_A = a_A c, \quad c_B = a_B c$$
6. Both parties compute their partial signatures $$s_A = r_A + c_Ax_A, \quad s_B = r_B + c_B x_B$$
and only share $s_A, s_B$ with each other. Both party then compute the aggregated signature $s = s_A + s_B$. 
7. They output $(R, s)$ as their final signature. 

Suppose Carol wants to verify their signature. She checks the following equality $$sG = R + cX$$

We want to fix some additional notations before diving into adaptor signatures. Suppose there are two messages $m^1, m^2$ that Alice and Bob want to sign. They just do everything above twice. To make our notations compact, we use superscripts to distinguish between the parameters for two messages (and they are not powers). 

Starting step 4, each party produces two secret nonces and two public nonces. For example, Alice produces $r_A^1, r_A^2$ and $R_A^1, R_A^2$. In the end, they will produce two common signatures, one for each message, as $(R^1, s^1)$ and $(R^2, s^2)$. 

## Adaptor Signature and Atomic Swap
Consider the case where Alice and Bob want to exchange some money. Let $m^1$ be `Transfer 1000 HUF from Bob to Alice`, and $m^2$ be `Transfer 1 EUR from Alice to Bob`. If they were to sign these two messages using `MuSig` twice, one party will have an opportunity to embezzle the other one's money without paying back! Note in step 6, Alice has $s_A^1, s_A^2$, and Bob has $s_B^1, s_B^2$. They need to share these values with each other to produce valid final signatures $s^1$ and $s^2$. If Bob suddenly became malicious, he would ask Alice to share her values first. Then he would only share his $s_B^2$, and discard $s_B^1$ at the same time. In the end they have only produced one valid signature $(R^2, s^2)$ for $m^2$ so Bob will take Alice's money without paying back. 

How does Alice protect herself from such conspiracy? She can use adaptor signature to make sure that both parties cannot cheat. In this case, their exchange is called an atomic swap because they trade without a trusted third party. 

Everything remains the same for Alice and Bob until step 6. 

6. Instead of sending Bob $s_A^1$ and $s_A^2$ directly, Alice first randomly draws a secret offset $t \in_R \mathbb {Z}_p$ and computes the public offset $T = tG$. Then she computes her offset (adaptor) signatures for both messages by $$o_A^1 = t + s_A^1, \quad o_A^2 = t + s_A^2$$
Alice then sends $T, o_A^1, o_A^2$ to Bob. 
7. Bob computes his $s_B^1$ and $s_B^2$ in the usual way but this time, he cannot produce any common signature for any of the messages because he does not know $t$. However, he can still verify that Alice has produced correct offset signatures by checking $$(o_A^1 + s_B^1)G = T + R^1 + c^1X$$
and $$(o_A^2 + s_B^2)G = T + R^2 + c^2X$$
Once verified, he sends Alice $s_B^1$. 
8. Alice upon receiving $s_B^1$, computes the common signature for $m^1$ by $s^1 = s_A^1 + s_B^1$. Once Alice publishes $s^1$, she claims her money from Bob. The crucial observation is that, by publishing $s^1$, Alice essentially leaks the offset $t$ to Bob. 
9. Bob, upon seeing $s^1$, will be able to recover $t$ using $$t = o_A^1 - s_A^1 = o_A^1 - (s^1 - s_B^1)$$
Then, Bob can compute the common signature for $m^2$ by $$s^2 = s_A^2 + s_B^2 = (o_A^2-t) + s_B^2$$
Once Bob publishes $s^2$, he claims his money from Alice. 


## Implementation
I first tried to find someone else's implementation of `MuSig` online, but turned out to be a waste of time - none of them worked properly. In the end I had to implement it myself (using just a fraction of time I wasted on these online implementations). Using my own implementation, everything worked fine with Alice's secret values stubbed, but I could not verify Alice's adaptor signatures with values provided in the challenge. There must be something wrong with the hash function! I contacted the creator, provided my solution script, and got back with one more piece of information "They chose to encode the multiset of public keys by hashing it."

The problem was about how to encode the multiset $L$. In the `MuSig` paper, the author only says $\langle L \rangle$ is some unique encoding of $L$, without specifying exactly how to encode it. While I used $\langle L \rangle = L$, the challenge used $\langle L \rangle = H(L)$. Everything worked fine after fixing this problem. 

The solution uses [SageMath](https://www.sagemath.org/). 
```python
import hashlib
from Crypto.Util.number import bytes_to_long, long_to_bytes

q = ZZ('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F')
E = EllipticCurve(GF(q), [0, 7])
G = E(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798, 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8)
p = G.order()
def to_bytes(a): 
    return long_to_bytes(int(a[0])) + long_to_bytes(int(a[1]))

def hashint(a):
    h = hashlib.sha256()
    h.update(a)
    return int(h.hexdigest(), 16) % p

# Alice secretly generates (stubbed)
xA = 7606021191029346730294824106541689883132070989190040895156382289316678384418
rA1 = 40875027838411243928019541729497066531622776173109786711523984194368326234828
rA2 = 50875027838411243928019541729497066531622776173109786711523984194368326234828
t = 60875027838411243928019541729497066531622776173109786711523984194368326234828

# Bob secretly generates
xB = 6606021191029346730294824106541689883132070989190040895156382289316678384418
rB1 = 30875027838411243928019541729497066531622776173109786711523984194368326234828
rB2 = 9030834884145650844587623971459173810430385651246788423594108749614646334103

# Alice publishes
M1 = "Transfer 1000 HUF from Bob to Alice".encode()
XA = xA*G
RA1 = rA1*G
RA2 = rA2*G

# Bob publishes
M2 = "Transfer 1 EUR from Alice to Bob".encode()
XB = xB*G
RB1 = rB1*G
RB2 = rB2*G

# Alice and Bob both have
L = long_to_bytes(hashint(to_bytes(XA) + to_bytes(XB)))
aA = hashint(L + to_bytes(XA))
aB = hashint(L + to_bytes(XB))
X = aA * XA + aB * XB
R1 = RA1 + RB1
R2 = RA2 + RB2
c1 = hashint(to_bytes(X) + to_bytes(R1) + M1)
c2 = hashint(to_bytes(X) + to_bytes(R2) + M2)

# Alice sends to Bob
SA1_off = (t + rA1 + aA*c1*xA) % p
SA2_off = (t + rA2 + aA*c2*xA) % p
T = t*G

# Bob computes and verifies
# If verified, send to Alice SB1
SB1 = (rB1 + aB*c1*xB) % p
assert(((SB1 + SA1_off) % p)*G == (R1 + T) + c1*X)

# Alice computes and publishes
sC1 = (SB1 + SA1_off - t) % p

# Alice claims her money by verifying
assert(sC1*G == R1 + c1*X)

# Bob computes, publishes sC2
t = (SB1 + SA1_off - sC1) % p
SB2 = (rB2 + aB*c2*xB) % p
sC2 = (SB2 + SA2_off - t) % p

# Bob claims his money by verifying
assert(sC2*G == R2 + c2*X)
```








