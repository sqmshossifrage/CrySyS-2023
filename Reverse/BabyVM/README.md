As the name suggests, we are facing a binary using VM-based code obfuscation. In plain words, the program runs on top of a VM using custom instruction set. Our task is to understand their implementation of instruction set to discover what the program actually does. 

Since we are given two files, it suggests that each contains some custom instructions. We need to figure out the instructions first. The binary is stripped but relatively easy to analyze in Ghidra. Following the `__libc_start_main` in entry point `FUN_00101130`, we identify the `main` function as `FUN_00101df3`. Then `FUN_00101219` allocates `0x40d` bytes memory for the VM and displays a menu for loading levels. Here, `param_1` is the address for the base of the VM. To increase readability, whenever we say "offset `0x400`", we actually mean `(param_1 + 0x400)`. Thus the source `.mad46` files are in offset `0x0-0x2ff`. 

`FUN_00101da5` is the start of the VM; it contains a loop that mimics CPU cycles and offset `0x405` is like `rip`. Function `FUN_00101bb4` translates `.mad46` file into opcodes and operands. Then `FUN_00101a3e` chooses and executes these instructions according to the opcodes. Inside `FUN_00101a3e`, we can see 9 instructions (the `default` statement hints this); inside each instruction, there is a function that selects registers `FUN_00101410` (again, `default` statement hints this). There are 6 registers at offset `0x400-0x405`. 

Now it remains to reverse the instruction set. Fortunately there are only 9 instructions, roughly equivalent to `mov`, `add`, `sub`, and so on. The VM's "stack" starts at offset `0x300` and grows to higher addresses. Moreover, offset `0x406` is a flag register. 

It is not necessary to write a disassembler for this challenge. Using a debugger and only manually disassembling the curcial parts would be enough. For level 1, just set a breakpoint at the right place because the password is checked character by character. For level 2, we have to disassemble and understand the control flow. 