Reading the text output file and searching some key terms online reveal that it is from a [Triton](https://github.com/jonathansalwan/Triton) analysis result. I watched [Triton and Symbolic Execution on GDB](https://www.youtube.com/watch?v=LOTQIAVXdCI) to undertand Triton better (the video is in Mandarin though). The symbolic expression is written in [SSA form](https://en.wikipedia.org/wiki/Static_single-assignment_form). To understand the content of the file, I also read [What kind of semantics information Triton can provide?](https://shell-storm.org/blog/What-kind-of-semantics-information-Triton-can-provide/) briefly. 

Initially I had no idea how to reverse the binary because it was very complicated with a lot of functions. Tracking from the entry point on Ghidra ended up losing my way in the maze of functions. 

I could only solve it when the creator posted a hint during the CTF. Reading the hint, we know that there is a [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) for 5 different cases. Reading the text output again we can identify exactly 5 functions. This gives a strong hint that these functions are actually the cases being matched. Each case encodes a byte and we need to decode them all. Reading the content of the output, we can just ignore all the complicated flag terms like `cf`, `of`, `pf`, `sf`, `zf`. We know that this is a Windows binary so most probably it follows the calling convention of `rcx` as its first argument. Thus we guess `rcx` is the address of the `i`-th byte to be encoded. The `rax` is missing in some functions, so we guess that `rdi` actually contains the output byte after encoding. Moreover, `r13` involves in a lot of computations so we guess it is the index `i`. 

I then installed the Triton API and tried to let Triton parse them for me. However, reading both the Python and C++ API did not help much for this job. I had difficulties instantiate any `AstNode` from the text file. Maybe we have to write a parser ourselves to convert strings into the desired data types? Fortunately there were only 5 cases in pattern matching. I ended up simplifying them by hand and it was not hard. 

There is no need to include any solver script because the creator has already hinted a lot. Though I solved the challenge with a hint like cheating, I did want to know the way to solve this challenge without the hint. Based on the hint, I guess the binary may contain some symbols from Rust. However, I could not find any Ghidra Plugin for matching Rust symbols. I would be glad to see some explanations on how to tackle this challenge without the hint. 